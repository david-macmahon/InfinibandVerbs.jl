var documenterSearchIndex = {"docs":
[{"location":"#InfinibandVerbs.jl-Documentation","page":"InfinibandVerbs.jl Documentation","title":"InfinibandVerbs.jl Documentation","text":"","category":"section"},{"location":"","page":"InfinibandVerbs.jl Documentation","title":"InfinibandVerbs.jl Documentation","text":"warning: ðŸš§ ðŸ‘· Under construction ðŸ‘· ðŸš§\nThis documenation is under construction.","category":"page"},{"location":"","page":"InfinibandVerbs.jl Documentation","title":"InfinibandVerbs.jl Documentation","text":"Here are some of the more commonly used high level API functions.  They are presented in these sections:","category":"page"},{"location":"","page":"InfinibandVerbs.jl Documentation","title":"InfinibandVerbs.jl Documentation","text":"","category":"page"},{"location":"#General-functions","page":"InfinibandVerbs.jl Documentation","title":"General functions","text":"","category":"section"},{"location":"","page":"InfinibandVerbs.jl Documentation","title":"InfinibandVerbs.jl Documentation","text":"These structure and functions are useful for both sending and receiving packets.","category":"page"},{"location":"#InfinibandVerbs.Context","page":"InfinibandVerbs.jl Documentation","title":"InfinibandVerbs.Context","text":"Context(dev_name, port_num; <kwargs>)\n\nCreate a Context object to use Infiniband Verbs on port_num of dev_name.\n\nKeyword arguments, described in the extended help, control various aspects of the created objects.  Their default values request minimal resources, but non-trivial applications will need to request more resources depending on the application's needs.  Upon successful return, the Context's queue pair will be in the IBV_QPS_INIT state.\n\nExtended help\n\nThe Context structure manages the following fields (so you don't have to):\n\nField name Type Description\ncontext Ptr{ibv_context} Context from C library\npd Ptr{ibv_pd} Protection domain\nsend_comp_channel Ptr{ibv_comp_channel} Send completion channel\nrecv_comp_channel Ptr{ibv_comp_channel} Receive completion channel\nsend_cq Ptr{ibv_cq} Send completion queue\nrecv_cq Ptr{ibv_cq} Receive completion queue\nqp Ptr{ibv_qp} Queue pair\nsend_wcs Vector{ibv_wc} Send work completions\nrecv_wcs Vector{ibv_wc} Recv work completions\n\nThe following fields of the Context structure hold sizing information:\n\nField name Type Description\nsend_cqe UInt32 Number of send completion queue events\nrecv_cqe UInt32 Number of recv completion queue events\nmax_send_wr UInt32 Max number of posted send work requests\nmax_recv_wr UInt32 Max number of posted recv work requests\nmax_send_sge UInt32 Max number of SGEs per send work request\nmax_recv_sge UInt32 Max number of SGEs per recv work request\n(!) max_inline_data UInt32 Maximum amount of inline data\n\nThe Context constructor supports the following keyword arguments:\n\nKeyword argument Default Description\nforce false Allow dev_name:port_num to be inactive\n(-) send_cqe 1 Number of events for send completion queue\n(-) recv_cqe 1 Number of events for recv completion queue\n(-) max_send_wr 1 Maximum number of send work requests\n(-) max_recv_wr 1 Maximum number of recv work requests\n(-) max_send_sge 1 Maximum number of SGEs for send WR sg_lists\n(-) max_recv_sge 1 Maximum number of SGEs for recv WR sg_lists\nreq_notify_send true Request send CQ notifications\nreq_notify_recv true Request recv CQ notifications\nsolicited_only_send false solicited_only for send CQ notifications\nsolicited_only_recv false solicited_only for recv CQ notifications\n(!) comp_vector 0 Completion queue comp_vector\n(!) max_inline_data 0 Maximum inline data for QP\n(!) qp_type IBV_QPT_RAW_PACKET QP type\n\ninfo: Info\nKeyword arguments marked with (-) can be passed as -1 to use the device's maximum supported value, which can be retrieved from the Context field of the same name once constructed.  The actual values will be greater than or equal to the requested values.\n\nwarning: Warning\nFields and keyword arguments marked with (!) are for expert use.  Use and/or change at your own risk.\n\n\n\n\n\n","category":"type"},{"location":"#InfinibandVerbs.hascapability","page":"InfinibandVerbs.jl Documentation","title":"InfinibandVerbs.hascapability","text":"hascapability(ctx::Context, cap)\n\nReturn true if the device corresponding to ctx has capability cap.\n\ncap may be any one (and only one) of the ibv_device_cap_flags or ibv_raw_packet_caps flags.\n\nExtended help\n\nibv_device_cap_flags\nIBV_DEVICE_RESIZE_MAX_WR\nIBV_DEVICE_BAD_PKEY_CNTR\nIBV_DEVICE_BAD_QKEY_CNTR\nIBV_DEVICE_RAW_MULTI\nIBV_DEVICE_AUTO_PATH_MIG\nIBV_DEVICE_CHANGE_PHY_PORT\nIBV_DEVICE_UD_AV_PORT_ENFORCE\nIBV_DEVICE_CURR_QP_STATE_MOD\nIBV_DEVICE_SHUTDOWN_PORT\nIBV_DEVICE_INIT_TYPE\nIBV_DEVICE_PORT_ACTIVE_EVENT\nIBV_DEVICE_SYS_IMAGE_GUID\nIBV_DEVICE_RC_RNR_NAK_GEN\nIBV_DEVICE_SRQ_RESIZE\nIBV_DEVICE_N_NOTIFY_CQ\nIBV_DEVICE_MEM_WINDOW\nIBV_DEVICE_UD_IP_CSUM\nIBV_DEVICE_XRC\nIBV_DEVICE_MEM_MGT_EXTENSIONS\nIBV_DEVICE_MEM_WINDOW_TYPE_2A\nIBV_DEVICE_MEM_WINDOW_TYPE_2B\nIBV_DEVICE_RC_IP_CSUM\nIBV_DEVICE_RAW_IP_CSUM\nIBV_DEVICE_MANAGED_FLOW_STEERING\n\nibv_raw_packet_caps\nIBV_RAW_PACKET_CAP_CVLAN_STRIPPING\nIBV_RAW_PACKET_CAP_SCATTER_FCS\nIBV_RAW_PACKET_CAP_IP_CSUM\nIBV_RAW_PACKET_CAP_DELAY_DROP\n\n\n\n\n\n","category":"function"},{"location":"#InfinibandVerbs.post_wrs","page":"InfinibandVerbs.jl Documentation","title":"InfinibandVerbs.post_wrs","text":"post_wrs(ctx::Context, wr::Ptr; modify_qp=false) -> nothing\npost_wrs(ctx::Context, wrs::Vector, idx=1; modify_qp=false) -> nothing\n\nPost linked WRs to the Context's QP.\n\nwr may be a Ptr{ibv_send_wr}/Ptr{ibv_recv_wr} or Vector{ibv_send_wr}/Vector{ibv_recv_wr}.  Passing a Vector will only post the WRs that are part of the linked list headed by the WR wrs[idx] of the Vector, which may not be the same as wrs[idx:end].  Throws a SystemError if the underlying library call fails, otherwise returns nothing.\n\nIf modify_qp is true, the Context's QP will be transitioned appropriately for the work request type:\n\nFor ibv_recv_wr, the QP will be transitioned to a \"ready-to-receive\" compatible state after posting the WRs.\nFor ibv_send_wr, the QP will be transitioned to the \"ready-to-send\" state before posting the WRs.\n\n\n\n\n\n","category":"function"},{"location":"#InfinibandVerbs.repost_loop","page":"InfinibandVerbs.jl Documentation","title":"InfinibandVerbs.repost_loop","text":"repost_loop(callback, ctx::Context, wrs, timeout_ms, callback_args...)\n\nRun a loop that processes work completions and reposts work requests.\n\nThe callback argument is a user supplied callback function described in detail below.  ctx is a Context struct.  wrs is a Vector{ibv_recv_wr} or Vector{ibv_send_wr} containing all the work requests being used. callback_args... are user supplied arguments that will be passed to the user supplied callback function.  Typically callback_args will include the packet buffers (or some other means of getting packet (fragment) buffers) and a Ref{Int} for accumulating the number of packets posted (useful when finding the next location in the packet buffers to use), but the caller is free to decide how to make use of callback_args....\n\nThe user supplied callback function callback is called for every work completion event that has a non-zero number of work completions.  It is also called if no work completions are received for timeout_ms milliseconds.  The callback function is passed the following arguments:\n\ncallback(wcs, num_wc, wrs, callback_args...)\n\nwcs: A Vector{ibv_wc} containing work completions (WCs)\nnum_wc: Number of valid entries in wcs (i.e. wcs[1:num_wc] are valid). If the callback function is called after a timeout, num_wc will be 0.\nwrs: The same recv_wrs or send_wrs passed to repost_loop\ncallback_args...: The same callback_args... parameters that were passed to repost_loop (the callback function may specify the individual extra arguments by name rather than splatting callback_args)\n\nwarning: Warning\nThis function can block waiting for work completion events.  It should be run in a separate thread from the main Julia thread so that it will not interfere with the Julia scheduler.  Usually this will be done using Threads.@spawn.  For example (using repost_loop to receive):recvtask = Threads.@spawn repost_loop(recv_callback, ctx, recv_wrs, timeout, user1, user2)Note that Threads.@spawn does not create new threads.  To use multiple threads, Julia must be started with more than one thread (e.g. julia -t 4).  Additional threads cannot be created after startup.\n\nExtended help\n\nThe main purpose of the callback function is to update the SG lists of the completed work requests (WRs) with pointers to the next available packet (fragment) buffer location(s).  The callback function should return the number of work requests for repost_loop to repost.  Returning 0 from the callback will keep repost_loop running but no WRs will be reposted.  Returning a negative value will cause repost_loop to return (i.e. end).  When num_wc is 0 (i.e. after a timeout), the callback should return a value less than 0 to end the loop or 0 to keep waiting for more work completions (i.e. packets).\n\nFor streaming applications that run \"forever\", the callback function should update the SG lists of the WRs for all num_wc WCs and return num_wc.\n\nApplications that want to process exactly N WRs should pass N as part of callback_args... as well as two Ref{Int} parameters so the callback function can accumulate the number of WRs posted and the number of WRs done/processed. As the number of WRs posted approaches N the callback may return a number less than than num_wc.  Such applications should also pay attention to the number of done/processed WRs and return a negative value when it equals N (or exceeds N, but that should never happen if exactly N WRs are posted).\n\n\n\n\n\n","category":"function"},{"location":"#Send-related-functions","page":"InfinibandVerbs.jl Documentation","title":"Send related functions","text":"","category":"section"},{"location":"","page":"InfinibandVerbs.jl Documentation","title":"InfinibandVerbs.jl Documentation","text":"These functions are useful when sending packets.","category":"page"},{"location":"#InfinibandVerbs.create_send_wrs","page":"InfinibandVerbs.jl Documentation","title":"InfinibandVerbs.create_send_wrs","text":"create_send_wrs(ctx::Context, bufs, num_wr[, npad]; offload=false, post=false) -> send_wrs, sges, mrs\ncreate_send_wrs(mrs, bufs, num_wr[, npad]) -> send_wrs, sges\n\nReturn num_wr ibv_send_wr work requests (WRs) and their associated scatter-gather (SG) lists.\n\nbufs and mrs, if given, must be Vectors.  If the form with ctx::Context is called, the memory region(s) of bufs will be registered before calling the mrs form and the resulting MRs will be returned in addition to the WRs and SG lists.  If memory regions mrs are given, their lkey values will be used when populating the SG lists so mrs must correspond to bufs.  All of the Arrays in bufs must hold the same number of packets (i.e. packet fragments).  See the doc string for create_sges for details about the npad parameter.\n\nThe Context form also accepts keyword arguments offload and post, both of which default to false.  If offload is true the WRs will be setup to offload the IP checksum calculation to the NIC.  You can use hascapability to check whether your device supports this.  See the man page of ibv_post_send for more details.  If post is true, the Context's QP will be transitioned to the \"ready-to-send\" (RTS) state and the work requests will be posted.\n\n\n\n\n\n","category":"function"},{"location":"#Receive-related-functions","page":"InfinibandVerbs.jl Documentation","title":"Receive related functions","text":"","category":"section"},{"location":"","page":"InfinibandVerbs.jl Documentation","title":"InfinibandVerbs.jl Documentation","text":"These functions are useful when receiving packets.","category":"page"},{"location":"#InfinibandVerbs.create_recv_wrs","page":"InfinibandVerbs.jl Documentation","title":"InfinibandVerbs.create_recv_wrs","text":"create_recv_wrs(ctx::Context, bufs, num_wr[, npad]; post=false) -> recv_wrs, sges, mrs\ncreate_recv_wrs(mrs, bufs, num_wr[, npad]) -> recv_wrs, sges\n\nReturn num_wr ibv_recv_wr work requests (WRs) and their associated scatter-gather (SG) lists.\n\nbufs and mrs, if given, must be Vectors.  If the form with ctx::Context is called, the memory region(s) of bufs will be registered before calling the mrs form and the resulting MRs will be returned in addition to the WRs and SG lists.  If memory regions mrs are given, their lkey values will be used when populating the SG lists so mrs must correspond to bufs.  All of the Arrays in bufs must hold the same number of packets (i.e. packet fragments).  See the doc string for create_sges for details about the npad parameter.\n\nThe Context form also accepts keyword argument post (default false).  If post is true, the work requests will be posted and the Context's QP will be transitioned to a \"ready-to-receive\" (RTR) compatible state.\n\n\n\n\n\n","category":"function"},{"location":"#InfinibandVerbs.create_flow","page":"InfinibandVerbs.jl Documentation","title":"InfinibandVerbs.create_flow","text":"create_flow(qp, port_num; <kwargs>) -> Ptr{ibv_flow}\ncreate_flow(ctx::Context; <kwargs>) -> Ptr{ibv_flow}\n\nCreate a flow rule to specify which packets to receive.\n\nThe flow rule will be created for queue pair qp, port number port_num (or ctx.qp and ctx.port_num).\n\nVarious attributes and selectors of the flow rule can be specified by keyword arguments as described in the extended help.  The returned Ptr{ibv_flow} can be passed to ibv_destroy_flow to remove the flow rule.\n\nExtended help\n\nAttributes\n\nThese keyword arguments set general attributes of the flow rule.  See the Linux manual page for ibv_create_flow for more details.\n\nGeneral flow rule attributes:\nflow_type one of :normal (default), :all, :mc, or :sniffer\npriority defaults to 0\nflow_flags defaults to 0\n\nSelectors\n\nKeyword arguments that are unspecified (or zero) are not used for matching. Integer values will be converted to network byte order as necessary.\n\nEthernet layer selectors\ndmac::NTuple{6, UInt8}: destination MAC address to match\nsmac::NTuple{6, UInt8}: source MAC address to match\nethtype: EtherType value to match (e.g. 0x0800 for IPv4 packets)\nvlan: VLAN tag to match\nIPv4 layer selectors (can be UInt32 or IPv4)\nsip: source IPv4 address (e.g. 0x0a000123 or ip\"10.0.1.35\")\ndip: destination IPv4 address\nproto: IP protocol\ntos: Type of service (aka DSCP/ECN)\nttl: Time to live\nflags: IP flags\nTCP/UDP layer selectors\ndport: destination TCP/UDP port to match\nsport: source TCP/UDP port to match\ntcpudp: one of :udp (default) or :tcp.  Specifies whether sport/dport should match UDP or TCP ports.  To match all UDP or all TCP packets, use the IPv4 layer proto selector instead.\n\n\n\n\n\n","category":"function"},{"location":"#InfinibandVerbs.destroy_flow","page":"InfinibandVerbs.jl Documentation","title":"InfinibandVerbs.destroy_flow","text":"destroy_flow(flow) -> nothing\n\nDestroy flow that was created by create_flow.  Packets specified by flow will no longer be received from the flow's device and port.\n\n\n\n\n\n","category":"function"},{"location":"#Lesser-directly-used-functions","page":"InfinibandVerbs.jl Documentation","title":"Lesser directly-used functions","text":"","category":"section"},{"location":"","page":"InfinibandVerbs.jl Documentation","title":"InfinibandVerbs.jl Documentation","text":"These functions see less direct use because they are called by more commonly used functions, but sometimes the more commonly used functions expose parameters that are passed on to these functions.","category":"page"},{"location":"#InfinibandVerbs.create_sges","page":"InfinibandVerbs.jl Documentation","title":"InfinibandVerbs.create_sges","text":"create_sges(bufs, lkeys, num_wr[, npad]) -> Matrix{ibv_sge}\n\nReturn a Matrix{ibv_sge} of size (length(bufs), num_wr).\n\nEach column of the returned Matrix is an SG list initialized to point to the first num_wr packets of bufs.  Both bufs and lkeys must be Vectors of the same length.  The elements of bufs are Arrays that must be sized for the same number of packets and num_wr must not exceed this number.  The elements of lkeys must be the lkey values corresponding to the registered memory regions for bufs.\n\nThe Arrays in bufs may include a number of padding bytes along their first dimension to improve alignment of the packet data.  The number of padding bytes may be specified by passing npad.  npad may be a single Int to apply the same value to all bufs Arrays or a Vector{Int} to specify values for all the bufs Array.  The default value of npad is 0 (i.e. no padding).  The value(s) of npad will be subtracted from the number of bytes in the first dimensions of the bufs Array.\n\n\n\n\n\n","category":"function"},{"location":"#Index","page":"InfinibandVerbs.jl Documentation","title":"Index","text":"","category":"section"},{"location":"","page":"InfinibandVerbs.jl Documentation","title":"InfinibandVerbs.jl Documentation","text":"","category":"page"}]
}
